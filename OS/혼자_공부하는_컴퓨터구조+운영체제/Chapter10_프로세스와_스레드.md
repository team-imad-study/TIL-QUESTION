# DAY2
작성일 : 2024/03/29

> 범위
- 01 프로세스 개요
- 02 프로세스 상태와 계층구조
- 03 스레드

---
> 작성자 : 
---
> 작성자 : Quarang

## Q. 프로세스 계층 구조 중, 생성 및 종료 과정에서 벌어질 수 있는 문제점들을 생각해보시오.


> 부모프로세스와 자식프로세스가 분리된 이유는 무엇?
- 특정 프로세스의 크기가 클 때 효율적으로 작업을 처리하기 위해
- 자식 프로세스들은 부모프로세스와 병렬적으로 동작하여 동작이 완료되었음을 부모 프로세스에게 알림
- 자식 프로세스에서 작업을 완료하면 각각의 결과를 수집하여 전체 프로세스를 완료함


> 프로세스 생성 과정
- 프로세스는 `fork()`을 호출하여 프로세스를 복사하고 `exec()` 시스템콜을 호출하여 복사된 프로세스에 새로운 내용을 덮어씀
- 부모는 `wait()`을 호출해 자식의 종료를 기다림
- 자식들이 작업을 모두 완료하면 `exit()`을 호출해 종료 되었음을 알림
- 부모는 대기상태가 끝나고 자식이 **사용했던 자원들을 커널에 반납**하고 다음로직을 수행함
- 이때 2가지 경우에 따라 자식프로세스는 `좀비 프로세스`와 `고아 프로세스`가 될 수 있음

> 좀비 프로세스 
- 부모 프로세스가 사용했던 자원을 커널에 반납하지 않을 시에 잔해가 생겨 메모리에 계속 남아있는 경우
- 부모가 `wait()`을 사용하지 않았을 시 이런 문제가 생김
- 좀비 프로세스를 `abort()`을 호출해 강제 종료 시키거나, 그냥 부모 프로세스를 정지 시키면 됨

> 고아 프로세스
- 자식 프로세스가 종료되기 전에 부모프로세스가 종료된 경우
- 이 역시 부모가 `wait()`을 사용하지 않았을 시 이런 문제가 생김
- 이럴 경우 모든 프로세스의 조상 프로세스인 `init 프로세스`에게 자식을 입양 시킴
- init 프로세스는 1의 PID를 가지게 됨


> 참고
- https://velog.io/@buna1592/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%A2%80%EB%B9%84-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EA%B3%A0%EC%95%84-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-Zombie-Orphan-Process
- https://code-lab1.tistory.com/39
- https://ko.wikipedia.org/wiki/Init
- https://velog.io/@yuseogi0218/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%83%9D%EC%84%B1%EA%B3%BC-%EC%86%8C%EB%A9%B8
---

> 작성자 : NCookie

## 스레드의 장점

### 자원 공유
쓰레드는 같은 프로세스 내에서 실행되기 때문에 프로세스의 자원(메모리, 파일 등)을 공유할 수 있다. 이를 통해 데이터 공유와 효율적인 작업 분담이 가능하다.

### 빠른 생성과 종료
쓰레드는 프로세스 내에서 생성되고 종료되는데, 이는 프로세스의 생성 및 종료보다 더 빠르다. 따라서 작업의 동시성을 향상시킬 수 있다.

### 작은 메모리 오버헤드
쓰레드는 프로세스와는 달리 독립적인 메모리 공간을 가지지 않기 때문에, 프로세스를 생성하는 것보다 적은 메모리 오버헤드를 가진다.

### 빠른 컨텍스트 전환
쓰레드 간의 전환은 프로세스 간의 전환보다 더 빠르다. 이는 쓰레드가 프로세스 내에서 실행되기 때문에 추가적인 자원 할당이 필요하지 않기 때문이다.


## 리눅스에서 프로세스와 스레드를 구분하지 않는 이유는 뭘까?

### 리눅스 철학 - "모든 것이 파일이다"

리눅스는 "모든 것이 파일" 철학을 따른다. 이는 리눅스 시스템에서 디바이스, 네트워크 소켓, 프로세스 등 모든 것을 파일로 다룬다는 의미다. 따라서 리눅스에서는 프로세스와 스레드를 모두 파일 형태로 다룬다.

### 경량 프로세스

리눅스에서 쓰레드는 `경량 프로세스(Lightweight Process, LWP)`로 구현되는 경우가 일반적이다. 이는 프로세스와 달리 독립적인 메모리 영역을 가지지 않으며, 프로세스 내에서 스택 메모리와 레지스터 등 일부 자원을 공유한다. 이로써 쓰레드 간의 전환 및 통신이 더 빠르게 이루어진다.

사용자(개발자) 입장에서 봤을 때에는 프로세스와 스레드는 별개의 것이지만, 리눅스의 커널 입장에서 봤을 때 이 둘은 메모리를 공유한다는 점을 빼고 같은 COE(Context of Execution)이다. 따라서 커널 라이브러리 등에서는 프로세스와 스레드를 구분하지 않고 `task`라고 칭한다.

리누스 토발즈에 의하면 스레드/프로세스 사고 방식을 중심으로 디자인하지 말고, COE 사고 방식을 중심으로 설계해야 한다고 당부한다.


---
