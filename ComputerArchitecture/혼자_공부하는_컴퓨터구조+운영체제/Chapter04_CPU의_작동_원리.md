# DAY2
작성일 : 2024/03/08

> 범위
- 01 ALU와 제어장치
- 02 레지스터

---

> 작성자 : KUN

## Q. 제어장치는 클럭신호를 받아 신호에 맞춰 동작한다고 배웠습니다. 이때 사용하는 클럭신호는 무엇을 위해 사용할까요?

### 클럭신호는 디지털 회로에서 데이터 전송과 처리를 “동기화” 하고 조정하는 데 중요한 역할을 합니다.

메모리 와 시스템버스 ,RAM 등에서도 데이터 전송을 동기화하고 통신을 조정하기 위해 클럭신호를 사용함

그래픽카드의 그래픽 처리장치 에서도 GPU가 크래픽 처리를 위해 클럭신호를 사용하며 픽셀 처리 및 그래픽 렌더링을 동기화함

### 클럭신호를 사용하는 주된 이유는 "동기화" 라는 키워드가 꼭 들어가야 함을 기억할것!


---

> 작성자 : NCookie

## 베이스 레지스터 주소 지정 방식의 용도 (Ch04-2)

### 배열(Array) 접근

배열의 첫 번째 요소의 주소를 베이스 레지스터에 저장하고, 오프셋(offset)을 더해 원하는 요소에 접근할 수 있다.

```assembly
; 배열의 주소를 베이스 레지스터에 저장
MOV R2, #base_address_of_array

; 원하는 인덱스 계산
MOV R3, #index
MUL R3, R3, #element_size ; 요소의 크기를 곱해 오프셋 계산

; 베이스 레지스터와 오프셋을 합쳐 실제 주소 계산
ADD R2, R2, R3

; 해당 주소의 데이터에 접근
MOV R1, [R2]
```

이렇게 하면 배열에서 index에 해당하는 요소에 접근할 수 있다. base_address_of_array는 배열의 시작 주소이고, index는 원하는 요소의 인덱스다. element_size는 배열의 각 요소의 크기를 나타낸다.

### 구조체(Struct) 접근

구조체의 필드에 접근하는 경우에도 베이스 레지스터 주소 지정 방식이 유용하다. 구조체의 시작 주소를 베이스 레지스터에 저장하고 필드의 오프셋을 더하여 필드에 접근할 수 있다.

```assembly
; 구조체의 시작 주소를 베이스 레지스터에 저장
MOV R2, #base_address_of_struct

; 필드의 오프셋 계산
MOV R3, #offset_of_field

; 베이스 레지스터와 오프셋을 합쳐 필드의 주소 계산
ADD R2, R2, R3

; 해당 필드의 데이터에 접근
MOV R1, [R2]
```

여기서 base_address_of_struct는 구조체의 시작 주소이고, offset_of_field는 접근하려는 필드의 오프셋을 나타낸다. 이 방식을 사용하면 구조체의 특정 필드에 쉽게 접근할 수 있다.

### 함수 인자(Arguments) 전달

베이스 레지스터 주소 지정 방식은 함수에 인자를 전달할 때도 유용하다. 함수 호출 시 인자들을 레지스터에 저장하고 함수가 호출될 때 베이스 레지스터를 통해 인자들에 접근할 수 있다.

```assembly
; 함수에 전달할 인자들을 레지스터에 저장
MOV R1, #arg1
MOV R2, #arg2

; 함수 호출 시 베이스 레지스터에 인자들의 주소 저장
MOV R3, #base_address_of_args
STR R1, [R3]
ADD R3, R3, #4 ; 다음 인자의 위치로 이동
STR R2, [R3]

; 함수 호출
BL function_name
```

이 경우 base_address_of_args는 함수에 전달할 인자들의 주소를 가리킨다. 함수가 호출되면 베이스 레지스터를 통해 인자들의 값을 전달할 수 있다.

이러한 예시에서 보듯이 베이스 레지스터 주소 지정 방식은 주로 메모리에 접근할 때 특정 위치를 기준으로 계산할 때 사용된다. 배열, 구조체, 함수 인자 등의 다양한 상황에서 유용하게 쓰일 수 있다.

---

# DAY3
작성일 : 2024/03/12

> 범위
- 03 명령어 사이클과 인터럽트
---

> 작성자 : NCookie

## 동기 인터럽트와 비동기 인터럽트의 차이와 각각의 예시 (Ch04-3)

### 동기 인터럽트 (Synchronous Interrupts):
- CPU 내부에서 발생: 동기 인터럽트는 CPU가 예상치 못한 상황에 직면했을 때 발생
- 소프트웨어적인 인터럽트: 소프트웨어적인 요인에 의해 발생하며, 프로그램 실행 중에 처리된다.
- 예시: 0으로 나누기 오류, 스택 오버플로우, 부적절한 메모리 접근 등

### 비동기 인터럽트 (Asynchronous Interrupts):
- CPU 외부에서 발생: 비동기 인터럽트는 주로 입출력 장치에 의해 발생하며, 알림과 같은 역할을 한다. 입출력 장치의 읽기 및 쓰기 시간은 CPU가 명령어를 수행하는 시간보다 훨씬 오래 걸리기 때문에, 입출력 작업이 완료되면 CPU에게 알림 신호를 보내도록 설계되었다.
- 하드웨어적인 인터럽트: 하드웨어적인 요인에 의해 발생하며, 주로 입출력 장치와 상호 작용할 때 발생한다.
- 예시: 디스크 I/O 완료, 네트워크 패킷 수신, 타이머 인터럽트 등

## 참고

- [컴퓨터 구조 #8 - 명령어 사이클과 인터럽트](https://uzinlab.tistory.com/100)
- [인터럽트(interrupt), 예외(exception), 트랩(trap)의 비교](https://melonicedlatte.com/computerarchitecture/2019/02/12/213856.html)
