# DAY3
작성일 : 2024/03/12

> 범위
- 01 빠른 CPU를 위한 설계 기법
- 02 명령어 병렬 처리 기법
- 03 CISC와 RISC

---

> 작성자 : KUN

## Q.멀티 스레드 기법에는 하드웨어적 스레드 소프트웨어적 스레드두가지 방법이 있습니다. 그중 하드웨어적 스레드의 하이퍼스레딩은 하나의 물리적 프로세서 코어에서 여러개의 가상 스레드 를 동시에 실행하는 기술 입니다. 그렇다면 하이퍼스레딩은 소프트웨어적 스레딩이 아닐까요? 이건 어떻게 된건지 설명해주세요

### 하드웨어적 스레드에서 코어에서 여러 개의 가상적인 스레드를 실행하는 것은 사실상 가상화된 형태의 스레드임

이러한 하이퍼스레딩(Hyper-Threading)과 같은 기술은
하드웨어적으로 구현되지만, 실제로는 물리적인 코어가 아니라
가상적인 코어를 생성하여 스레드를 동시에 실행하는 것입니다.
따라서 이러한 형태의 스레드는 하드웨어적 스레드이지만, 실제
로는 소프트웨어적으로 가상화된 형태의 스레드입니다.

### 하지만! 지금 구분 하는 하드웨어와 소프트웨어 스레딩의 차이는 해당 기술 구현에 소프트웨어적인 기술이 사용되었냐의 여부가 아닌 스레딩을 하고있는 부분이 하드웨어단 이냐 소프트웨어단 이냐 로 구분되는것이기 때문에 혼동하지 않도록 주의해야 

---
> 작성자 : Qurang

## Q. 메인스레드와 스레드의 실행 방식에 대해서 설명하시오

- 책에서 다루는 스레드 내용은 프로세스와의 관계 및 스레드의 전체적인 구조적 원리를 다루고 있음으로 소프트웨어 관점에서의 접근을 다룬 문제를 출제하기로 결정

#### 메인 스레드란?
- 프로그램이 시작될 때 기본적으로 실행되는 스레드
- 사용자 UI를 처리하거나 입력을 받는 등 `전체적인 프로그램의 생명주기를 제어`를 담당함

#### 메인 스레드 외에도 스레드가 존재할까?
- 한 스레드(메인스레드)에서 모든 일을 처리할 경우 컴퓨터 자원을 효율적으로 사용하기 힘들기 때문에, 특정 작업을 실행하기 위해 `CPU에서 스레드를 생성`해줌
- 다만 자동으로 스레드를 생성해주는 것이 아닌 `개발자에 의해 생성 및 관리`가 이루어지기 때문에, 이를 관리하는 방법을 개발자가 알아야함

#### 스레드 실행 방식

- 각 언어마다 구조적 차이가 있을 수 있음으로 각자 찾기를 추천함, 설명에 편의를 위해 예시는 swift로 들겠음
- 프론트앤드의 생명주기는 사용자에게 보여지는 UI를 처리하는 main스레드와 그 뒤에서 작업을 처리하는 background 스레드가 존재할 것임
- 위에서도 언급했듯이 프로그램이 시작하면 기본적으로 main 스레드에서 작동하기 때문에 다른 스레드로 `context switching`하는 작업이 필요함
- 실행 방식은 크게 `동기(synchronuos)`와 `비동기(Asynchronour)`, `직렬(Serial)`과 `동시(Concurrency)`


#### 동기와 비동기

- 동기와 비동기의 가장 큰 차이는 메인스레드가 다른 스레드의 작업을 `기다리느냐 안기다리느냐`의 차이임
- 동기 : 메인스레드가 다른 스레드에게 context switching을 하고 `그 작업이 완료 될때까지 기다리고 있음`.
- 비동기 : 메인스레드가 다른 스레드에게 context switching을 하고 `작업의 완료 유무를 신경쓰지 않고 다음 작업을 실행`함.

#### 그럼 동기를 쓸 이유가 없지 않나?
- 물론 비동기 작업을 할 경우 메인스레드가 비교적 자유로워진다는 장점이 있지만, 순차적으로 처리를 해야하는 경우 다른 스레드를 기다리고 작업을 해야하기 때문에 상황에 따라 비동기/동기 방식을 적절히 사용할 필요가 있음

#### 직렬과 동시

- 직렬과 동시는 `한 스레드에서만 작업을 처리할 것`이냐 `여러 스레드에 작업을 분배시킬 것`이냐의 차이
- 직렬 : `한개의 스레드`에서만 작업을 처리함
- 동시 : 작업의 양에 따라 `여러개의 스레드에 작업을 분배`해 처리함

#### 그럼 무조건 분배하는게 낫지 않나?
- 스레드를 여러곳으로 분배하는 순서는 정해져 있지만,(선입선출이기 때문) 끝나는 시점을 알 수가 없기 때문에 `순서가 중요한 작업을 처리`해야할 때 직렬 처리방식을 사용
- `순서가 중요하지 않고 빠른 작업을 원할 경우` 동시 처리방식을 사용함

#### 근데 왜 직렬과 병렬이 아닌 직렬과 동시로 분류가 될까?
- 여기서 말하는 병렬이란 `동시다발적`으로 데이터를 처리하는 것임
- 하지만 싱글코어 CPU를 사용하는 경우 이런 동시에 여러 쓰레드를 사용하는 것이 불가능함
- 왜냐면 `싱글코어에서 멀티스레딩을 실행`하는것은 `여러 스레드가 번갈아가며 실행되어 동시에 실행되는 것처럼 보이는 (시분할 스케쥴링)을 사용하기 때문`이고 이것이 동시적 처리임
- 싱글코어에서 멀티스레딩을 활용하는 경우 스레드끼리 작업을 주고 받는 작업인 `context switching`작업이 빈번하게 일어나고, 이 작업은 CPU에 다소 무리가 갈 수 있기 때문에 이런 환경이 다분하게 일어나게 될 장비일 경우에는 멀티코어 제품으로 보통 출시된다고 함.

**Example Code**
```swift
/Dispatch Queue 생성
/*
여기서 Dispatch Queue란?
java,C등에서는 스레드를 생성하기 위해 명시적으로 스레드를 만들고 해야할 작업을 생성한 스레드에 지정해주는 작업이 필요했음
멀티 스레딩 환경이 복잡하고 어려우며 리소스 관리를 직접 해줘야하는 등 단점이 있었음

 그래서 나온 것이 Dispatch Queue임
 작업(Dispatch Queue 옵션)을 정의해 Dispatch Queue에 명시만 해주면 알아서 적절한 스레드에 할당하게 됨
 */

let concurrntQueue = DispatchQueue(label: "concurrntQueue",attributes: .concurrent)
//concurrent - 병렬
let serialQueue = DispatchQueue(label: "SerialQueue")
//serial - 직렬


// 명령어 라인
func performTask(taskNumber: Int) {
    print("Task \(taskNumber) 인출")
    sleep(1)
    print("Task \(taskNumber) 해석")
    sleep(1)
    print("Task \(taskNumber) 실행")
    sleep(1)
    print("Task \(taskNumber) 저장")
    sleep(1)
}

// 병렬 처리할 작업 개수
let numberOfTasks = 5


//sync - 동기
//async - 비동기
//작업 시작
print(Thread.main)
for i in 1...numberOfTasks {
    concurrntQueue.async {
        performTask(taskNumber: i)
    }
}
print(Thread.main)

```

**SerialQueue.sync** : 메인 스레드의 작업 흐름이 queue에 넘긴 `태스크가 끝날때까지 멈춰있고`, 넘겨진 task는 queue에 먼저 담겨있던 작업들과 같은 스레드에 보내지기 때문에 해당 `작업들이 모두 끝나야 실행`

**ConcurrentQueue.sync** : 메인 스레드의 작업 흐름이 queue에 넘긴 `태스크가 끝날때까지 멈춰있고`, 넘겨진 task는 queue에 먼저 담겨있던 작업들과 다른 스레드에 보내질 수 있기 때문에 `해당 작업들이 모두 끝나지 않아도 실행 `

**SerialQueue.async** : 메인 스레드의 작업 흐름이 태스크를 queue에 `넘기자마자 반환되고` , 넘겨진 task는 queue에 먼저 담겨있던 작업들과 같은 스레드에 보내지기 때문에 `해당 작업들이 모두 끝나야 실행`

**ConcurrentQueue.async** : 메인 스레드의 작업 흐름이 태스크를 queue에 `넘기자마자 반환되고`, 넘겨진 task는 queue에 먼저 담겨있던 작업들과 다른 스레드에 보내질 수 있기 때문에 `해당 작업들이 모두 끝나지 않아도 실행`

> 참고: https://sujinnaljin.medium.com/ios-%EC%B0%A8%EA%B7%BC%EC%B0%A8%EA%B7%BC-%EC%8B%9C%EC%9E%91%ED%95%98%EB%8A%94-gcd-4-a621eca0a1d2 

---
> 작성자 : PCYSB

## Q. CISC는 파이프라이닝을 하기 힘들다 그런데 왜 현대에 ISA의 양대 산맥이라고 하는 것인가?

빠른 CPU를 사용하기 위해서는 파이프라이닝이 필요하다. 그렇지만 CISC의 경우에는 파이프라이닝 방식을 적용하기 위해서는 명령어 사이의 데이터 흐름을 실시간으로 분석해야 하는데 명령어가 복잡하면 이 분석에 사용되는 하드웨어가 너무 복잡해져서 설계 비용이 증가하고 회로의 속도가 떨어지기 때문에 CISC에서는 폭넓게 적용하기가 매우 어렵다. 그렇기에 사실상 현재의 CISC의 경우 RISC와 섞여 혼종처럼 남아있는 상태로 사실상 순수한 CISC 프로세서는 현재 시장에서 찾아볼 수 없다.

현대의 CISC의 기본적인 특징은 여전하다. 그렇지만 현대의 CISC는 RISC의 장점을 일부 공유하고 있다. 물론 그 반대의 경우도 있다. 이 처럼 현대의 CPU는 둘의 장점을 혼합해 사용한다. 실제로 현대의 CISC는 명령어를 나누어 1클럭에 맞춘다. 내부적으로는 RISC 처럼 사용하고있다.

---
