# DAY3
작성일 : 2024/03/12

> 범위
- 01 빠른 CPU를 위한 설계 기법
- 02 명령어 병렬 처리 기법
- 03 CISC와 RISC

---

> 작성자 : 

---
> 작성자 : Qurang

## Q. 메인스레드와 스레드의 실행 방식에 대해서 설명하시오

- 책에서 다루는 스레드 내용은 프로세스와의 관계 및 스레드의 전체적인 구조적 원리를 다루고 있음으로 소프트웨어 관점에서의 접근을 다룬 문제를 출제하기로 결정

#### 메인 스레드란?
- 프로그램이 시작될 때 기본적으로 실행되는 스레드
- 사용자 UI를 처리하거나 입력을 받는 등 `전체적인 프로그램의 생명주기를 제어`를 담당함

#### 메인 스레드 외에도 스레드가 존재할까?
- 한 스레드(메인스레드)에서 모든 일을 처리할 경우 컴퓨터 자원을 효율적으로 사용하기 힘들기 때문에, 특정 작업을 실행하기 위해 `CPU에서 스레드를 생성`해줌
- 다만 자동으로 스레드를 생성해주는 것이 아닌 `개발자에 의해 생성 및 관리`가 이루어지기 때문에, 이를 관리하는 방법을 개발자가 알아야함

#### 스레드 실행 방식

- 각 언어마다 구조적 차이가 있을 수 있음으로 각자 찾기를 추천함, 설명에 편의를 위해 예시는 swift로 들겠음
- 프론트앤드의 생명주기는 사용자에게 보여지는 UI를 처리하는 main스레드와 그 뒤에서 작업을 처리하는 background 스레드가 존재할 것임
- 위에서도 언급했듯이 프로그램이 시작하면 기본적으로 main 스레드에서 작동하기 때문에 다른 스레드로 `context switching`하는 작업이 필요함
- 실행 방식은 크게 `동기(synchronuos)`와 `비동기(Asynchronour)`, `직렬(Serial)`과 `동시(Concurrency)`


#### 동기와 비동기

- 동기와 비동기의 가장 큰 차이는 메인스레드가 다른 스레드의 작업을 `기다리느냐 안기다리느냐`의 차이임
- 동기 : 메인스레드가 다른 스레드에게 context switching을 하고 `그 작업이 완료 될때까지 기다리고 있음`.
- 비동기 : 메인스레드가 다른 스레드에게 context switching을 하고 `작업의 완료 유무를 신경쓰지 않고 다음 작업을 실행`함.

#### 그럼 동기를 쓸 이유가 없지 않나?
- 물론 비동기 작업을 할 경우 메인스레드가 비교적 자유로워진다는 장점이 있지만, 순차적으로 처리를 해야하는 경우 다른 스레드를 기다리고 작업을 해야하기 때문에 상황에 따라 비동기/동기 방식을 적절히 사용할 필요가 있음

#### 직렬과 동시

- 직렬과 동시는 `한 스레드에서만 작업을 처리할 것`이냐 `여러 스레드에 작업을 분배시킬 것`이냐의 차이
- 직렬 : `한개의 스레드`에서만 작업을 처리함
- 동시 : 작업의 양에 따라 `여러개의 스레드에 작업을 분배`해 처리함

#### 그럼 무조건 분배하는게 낫지 않나?
- 스레드를 여러곳으로 분배하는 순서는 정해져 있지만,(선입선출이기 때문) 끝나는 시점을 알 수가 없기 때문에 `순서가 중요한 작업을 처리`해야할 때 직렬 처리방식을 사용
- `순서가 중요하지 않고 빠른 작업을 원할 경우` 동시 처리방식을 사용함

#### 근데 왜 직렬과 병렬이 아닌 직렬과 동시로 분류가 될까?
- 여기서 말하는 병렬이란 `동시다발적`으로 데이터를 처리하는 것임
- 하지만 싱글코어 CPU를 사용하는 경우 이런 동시에 여러 쓰레드를 사용하는 것이 불가능함
- 왜냐면 `싱글코어에서 멀티스레딩을 실행`하는것은 `여러 스레드가 번갈아가며 실행되어 동시에 실행되는 것처럼 보이는 (시분할 스케쥴링)을 사용하기 때문`이고 이것이 동시적 처리임
- 싱글코어에서 멀티스레딩을 활용하는 경우 스레드끼리 작업을 주고 받는 작업인 `context switching`작업이 빈번하게 일어나고, 이 작업은 CPU에 다소 무리가 갈 수 있기 때문에 이런 환경이 다분하게 일어나게 될 장비일 경우에는 멀티코어 제품으로 보통 출시된다고 함.

**Example Code**
```swift
/Dispatch Queue 생성
/*
여기서 Dispatch Queue란?
java,C등에서는 스레드를 생성하기 위해 명시적으로 스레드를 만들고 해야할 작업을 생성한 스레드에 지정해주는 작업이 필요했음
멀티 스레딩 환경이 복잡하고 어려우며 리소스 관리를 직접 해줘야하는 등 단점이 있었음

 그래서 나온 것이 Dispatch Queue임
 작업(Dispatch Queue 옵션)을 정의해 Dispatch Queue에 명시만 해주면 알아서 적절한 스레드에 할당하게 됨
 */

let concurrntQueue = DispatchQueue(label: "concurrntQueue",attributes: .concurrent)
//concurrent - 병렬
let serialQueue = DispatchQueue(label: "SerialQueue")
//serial - 직렬


// 명령어 라인
func performTask(taskNumber: Int) {
    print("Task \(taskNumber) 인출")
    sleep(1)
    print("Task \(taskNumber) 해석")
    sleep(1)
    print("Task \(taskNumber) 실행")
    sleep(1)
    print("Task \(taskNumber) 저장")
    sleep(1)
}

// 병렬 처리할 작업 개수
let numberOfTasks = 5


//sync - 동기
//async - 비동기
//작업 시작
print(Thread.main)
for i in 1...numberOfTasks {
    concurrntQueue.async {
        performTask(taskNumber: i)
    }
}
print(Thread.main)

```

**SerialQueue.sync** : 메인 스레드의 작업 흐름이 queue에 넘긴 `태스크가 끝날때까지 멈춰있고`, 넘겨진 task는 queue에 먼저 담겨있던 작업들과 같은 스레드에 보내지기 때문에 해당 `작업들이 모두 끝나야 실행`

**ConcurrentQueue.sync** : 메인 스레드의 작업 흐름이 queue에 넘긴 `태스크가 끝날때까지 멈춰있고`, 넘겨진 task는 queue에 먼저 담겨있던 작업들과 다른 스레드에 보내질 수 있기 때문에 `해당 작업들이 모두 끝나지 않아도 실행 `

**SerialQueue.async** : 메인 스레드의 작업 흐름이 태스크를 queue에 `넘기자마자 반환되고` , 넘겨진 task는 queue에 먼저 담겨있던 작업들과 같은 스레드에 보내지기 때문에 `해당 작업들이 모두 끝나야 실행`

**ConcurrentQueue.async** : 메인 스레드의 작업 흐름이 태스크를 queue에 `넘기자마자 반환되고`, 넘겨진 task는 queue에 먼저 담겨있던 작업들과 다른 스레드에 보내질 수 있기 때문에 `해당 작업들이 모두 끝나지 않아도 실행`

> 참고: https://sujinnaljin.medium.com/ios-%EC%B0%A8%EA%B7%BC%EC%B0%A8%EA%B7%BC-%EC%8B%9C%EC%9E%91%ED%95%98%EB%8A%94-gcd-4-a621eca0a1d2 

---
> 작성자 : 
---
